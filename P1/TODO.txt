TODO:

    - przeszukiwanie grafu -> DFS


    KLASY:


    - menu
    - DP_TSP
    -

DONE:
        - zaimplementować klasy struktur:
                                            - stos
                                            - tablica grafu
        - Graph
        - Time



BRANCH AND BOUND:

1 Przejscie przez graf tak jak brutforce
2 Po pierwszym przejsciu zapsiuje wynik

3 Podczas kolejnych przejść za każdym razem sprawdzam czy dana gałęź nie bedzie już gorsza niż najlepsza po dołączeniu
  tej nowej krawędzi ORAZ czy ma potencjał na to by być lepsza
  Tzn. czy jeśli później będziemy dołączać tylko najtańsze krawędzi (choćby to nie miało sensu) to czy jest potencjał
  by było to tańsze niż najlepsze rozwiązanie.

PODEJSCIE OLI:

void BF::brut_force(Graph graph) {
    numOfCities = graph.getSize();                              // setting the value of filed

    visited = new bool[numOfCities];                       // list of currently visited cities

    // setting the lis tot false
    for(int i=0; i<numOfCities; i++){
        visited[i] = false;
    }
    visited[startingCity] = true;

    path_len = 0;           // length of path (number of already visited cities)
    best_cost = INT_MAX;     // minimal cost of checked paths (currently set as maximal integer value)
    current_cost = 0;       // cost of current path

    hamiltonian_path(startingCity, graph);  // starting the search for the most optimal hamiltonian path

    delete [] visited;
}


void BF::hamiltonian_path(int v, Graph graph) {

    int u;

    path.push_back(v);
    path_len++;
    //visited[v] = true;

    if(path_len < numOfCities){           // as long as there are cities that weren't visited
        visited[v] = true;                                     // set current city as visited


        for(u = 0; u < numOfCities; u++){       // checking all other cities
            if(!visited[u] && v != u){          // checking if this city is not visited and (graph.v[v][u] > 0)
                visited[u] = true;
                current_cost += graph.v[v][u];
                hamiltonian_path(u, graph);
                current_cost -= graph.v[v][u];  // going a step back after checking all exiting routes from this vertex
                visited[u] = false;             // marking this vertex as not visited on the way back
            }

        }
    }
    else if(startingCity != v){   // last city was reached
        current_cost += graph.v[v][startingCity]; //adding distance from last to starting city to make a loop
        if (current_cost < best_cost){
            best_cost = current_cost;
            best_path.copy(path);
            //path.print();
        }
        current_cost -= graph.v[v][startingCity];
    }

    std::cout<<"Czy 0 odziwedozne: " <<visited[0];
    BF::print();
    path_len--;
    path.pop();                                 // pop_back() from stack while exiting the recurrent
}