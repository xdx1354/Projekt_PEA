TODO:

    - przeszukiwanie grafu -> DFS


    KLASY:


    - menu
    - DP_TSP
    -

DONE:
        - zaimplementowaÄ‡ klasy struktur:
                                            - stos
                                            - tablica grafu
        - Graph
        - Time


PODEJSCIE OLI:

void BF::brut_force(Graph graph) {
    numOfCities = graph.getSize();                              // setting the value of filed

    visited = new bool[numOfCities];                       // list of currently visited cities

    // setting the lis tot false
    for(int i=0; i<numOfCities; i++){
        visited[i] = false;
    }
    visited[startingCity] = true;

    path_len = 0;           // length of path (number of already visited cities)
    best_cost = INT_MAX;     // minimal cost of checked paths (currently set as maximal integer value)
    current_cost = 0;       // cost of current path

    hamiltonian_path(startingCity, graph);  // starting the search for the most optimal hamiltonian path

    delete [] visited;
}


void BF::hamiltonian_path(int v, Graph graph) {

    int u;

    path.push(v);
    path_len++;
    //visited[v] = true;

    if(path_len < numOfCities){           // as long as there are cities that weren't visited
        visited[v] = true;                                     // set current city as visited


        for(u = 0; u < numOfCities; u++){       // checking all other cities
            if(!visited[u] && v != u){          // checking if this city is not visited and (graph.v[v][u] > 0)
                visited[u] = true;
                current_cost += graph.v[v][u];
                hamiltonian_path(u, graph);
                current_cost -= graph.v[v][u];  // going a step back after checking all exiting routes from this vertex
                visited[u] = false;             // marking this vertex as not visited on the way back
            }

        }
    }
    else if(startingCity != v){   // last city was reached
        current_cost += graph.v[v][startingCity]; //adding distance from last to starting city to make a loop
        if (current_cost < best_cost){
            best_cost = current_cost;
            best_path.copy(path);
            //path.print();
        }
        current_cost -= graph.v[v][startingCity];
    }

    std::cout<<"Czy 0 odziwedozne: " <<visited[0];
    BF::print();
    path_len--;
    path.pop();                                 // pop() from stack while exiting the recurrent
}